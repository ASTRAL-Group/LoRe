{"idx": 1, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=1\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_1,b_1,c_1)\\). Finally, return\n\\[\nx=\\big(a_1+b_1+c_1\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 8}
{"idx": 2, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=2\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_2,b_2,c_2)\\). Finally, return\n\\[\nx=\\big(a_2+b_2+c_2\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 4}
{"idx": 3, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=3\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_3,b_3,c_3)\\). Finally, return\n\\[\nx=\\big(a_3+b_3+c_3\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 12}
{"idx": 4, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=4\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_4,b_4,c_4)\\). Finally, return\n\\[\nx=\\big(a_4+b_4+c_4\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 20}
{"idx": 5, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=5\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_5,b_5,c_5)\\). Finally, return\n\\[\nx=\\big(a_5+b_5+c_5\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 16}
{"idx": 6, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=6\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_6,b_6,c_6)\\). Finally, return\n\\[\nx=\\big(a_6+b_6+c_6\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 24}
{"idx": 7, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=7\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_7,b_7,c_7)\\). Finally, return\n\\[\nx=\\big(a_7+b_7+c_7\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 32}
{"idx": 8, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=8\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_8,b_8,c_8)\\). Finally, return\n\\[\nx=\\big(a_8+b_8+c_8\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 16}
{"idx": 9, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=9\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_9,b_9,c_9)\\). Finally, return\n\\[\nx=\\big(a_9+b_9+c_9\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 17}
{"idx": 10, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=10\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_10,b_10,c_10)\\). Finally, return\n\\[\nx=\\big(a_10+b_10+c_10\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 53}
{"idx": 11, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=11\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_11,b_11,c_11)\\). Finally, return\n\\[\nx=\\big(a_11+b_11+c_11\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 44}
{"idx": 12, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=12\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_12,b_12,c_12)\\). Finally, return\n\\[\nx=\\big(a_12+b_12+c_12\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 6}
{"idx": 13, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=13\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_13,b_13,c_13)\\). Finally, return\n\\[\nx=\\big(a_13+b_13+c_13\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 12}
{"idx": 14, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=14\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_14,b_14,c_14)\\). Finally, return\n\\[\nx=\\big(a_14+b_14+c_14\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 6}
{"idx": 15, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=15\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_15,b_15,c_15)\\). Finally, return\n\\[\nx=\\big(a_15+b_15+c_15\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 18}
{"idx": 16, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=16\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_16,b_16,c_16)\\). Finally, return\n\\[\nx=\\big(a_16+b_16+c_16\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 30}
{"idx": 17, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=17\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_17,b_17,c_17)\\). Finally, return\n\\[\nx=\\big(a_17+b_17+c_17\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 48}
{"idx": 18, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=18\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_18,b_18,c_18)\\). Finally, return\n\\[\nx=\\big(a_18+b_18+c_18\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 64}
{"idx": 19, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=19\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_19,b_19,c_19)\\). Finally, return\n\\[\nx=\\big(a_19+b_19+c_19\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 30}
{"idx": 20, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=20\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_20,b_20,c_20)\\). Finally, return\n\\[\nx=\\big(a_20+b_20+c_20\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 25}
{"idx": 21, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=21\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_21,b_21,c_21)\\). Finally, return\n\\[\nx=\\big(a_21+b_21+c_21\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 51}
{"idx": 22, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=22\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_22,b_22,c_22)\\). Finally, return\n\\[\nx=\\big(a_22+b_22+c_22\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 15}
{"idx": 23, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=23\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_23,b_23,c_23)\\). Finally, return\n\\[\nx=\\big(a_23+b_23+c_23\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 27}
{"idx": 24, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=24\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_24,b_24,c_24)\\). Finally, return\n\\[\nx=\\big(a_24+b_24+c_24\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 49}
{"idx": 25, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=25\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_25,b_25,c_25)\\). Finally, return\n\\[\nx=\\big(a_25+b_25+c_25\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 15}
{"idx": 26, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=26\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_26,b_26,c_26)\\). Finally, return\n\\[\nx=\\big(a_26+b_26+c_26\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 43}
{"idx": 27, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=27\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_27,b_27,c_27)\\). Finally, return\n\\[\nx=\\big(a_27+b_27+c_27\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 53}
{"idx": 28, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=28\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_28,b_28,c_28)\\). Finally, return\n\\[\nx=\\big(a_28+b_28+c_28\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 19}
{"idx": 29, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=29\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_29,b_29,c_29)\\). Finally, return\n\\[\nx=\\big(a_29+b_29+c_29\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 19}
{"idx": 30, "type": "tri-register-extreme-xor", "task": "Given integer \\(n=30\\), initial registers \\((a_0,b_0,c_0)=(1,2,3)\\), a per-step modulus \\(p=31\\), and a final modulus \\(M=97\\).\nFor \\(t=1,2,\\dots,n\\), perform one round in the **strict order**:\n\n1. Compute\n\\[\nu_t=\\max(a_{t-1},\\,b_{t-1}),\\quad\nv_t=\\min(b_{t-1},\\,c_{t-1}),\\quad\nw_t=\\lvert a_{t-1}-c_{t-1}\\rvert.\n\\]\n\n2. **First**, do the full modulo-\\(p\\) update (temporary values):\n\\[\n\\tilde a_t=(u_t+v_t)\\bmod p,\\quad\n\\tilde b_t=(v_t+w_t)\\bmod p,\\quad\n\\tilde c_t=(w_t+u_t)\\bmod p.\n\\]\n\n3. **Then**, apply a conditional bitwise XOR (\\(\\oplus\\), same as `^` in most languages) to obtain \\((a_t,b_t,c_t)\\):\n\\[\n\\begin{cases}\na_t=\\tilde a_t\\oplus\\tilde b_t, & \\text{if} t\\equiv 0\\pmod 3;\\\\\nb_t=\\tilde b_t\\oplus\\tilde c_t, & \\text{if} t\\equiv 1\\pmod 3;\\\\\nc_t=\\tilde c_t\\oplus\\tilde a_t, & \\text{if} t\\equiv 2\\pmod 3.\n\\end{cases}\n\\]\n\nRepeat until you obtain \\((a_30,b_30,c_30)\\). Finally, return\n\\[\nx=\\big(a_30+b_30+c_30\\big)\\bmod M.\n\\]\nas the final answer.\n\n**Notes.**\n- Step 2 (the modulo-\\(p\\) update) must be completed before step 3 (the XOR) in every round.\n- All values are non-negative integers; XOR acts on the binary representation of non-negative integers.\n", "gt_ans": 33}
