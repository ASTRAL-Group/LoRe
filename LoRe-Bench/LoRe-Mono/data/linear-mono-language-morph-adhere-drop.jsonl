{"idx": 1, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 1 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_1) as a single string (no quotes).", "gt_ans": "preplay"}
{"idx": 2, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 2 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_2) as a single string (no quotes).", "gt_ans": "preplaying"}
{"idx": 3, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 3 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_3) as a single string (no quotes).", "gt_ans": "preworking"}
{"idx": 4, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 4 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_4) as a single string (no quotes).", "gt_ans": "unworking"}
{"idx": 5, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 5 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_5) as a single string (no quotes).", "gt_ans": "unworked"}
{"idx": 6, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 6 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_6) as a single string (no quotes).", "gt_ans": "uncooked"}
{"idx": 7, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 7 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_7) as a single string (no quotes).", "gt_ans": "recooked"}
{"idx": 8, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 8 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_8) as a single string (no quotes).", "gt_ans": "recooks"}
{"idx": 9, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 9 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_9) as a single string (no quotes).", "gt_ans": "rewrites"}
{"idx": 10, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 10 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_10) as a single string (no quotes).", "gt_ans": "antiwrites"}
{"idx": 11, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 11 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_11) as a single string (no quotes).", "gt_ans": "antiwriteer"}
{"idx": 12, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 12 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_12) as a single string (no quotes).", "gt_ans": "antitraveler"}
{"idx": 13, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 13 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_13) as a single string (no quotes).", "gt_ans": "pretraveler"}
{"idx": 14, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 14 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_14) as a single string (no quotes).", "gt_ans": "pretraveling"}
{"idx": 15, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 15 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_15) as a single string (no quotes).", "gt_ans": "preplaying"}
{"idx": 16, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 16 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_16) as a single string (no quotes).", "gt_ans": "unplaying"}
{"idx": 17, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 17 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_17) as a single string (no quotes).", "gt_ans": "unplayed"}
{"idx": 18, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 18 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_18) as a single string (no quotes).", "gt_ans": "unworked"}
{"idx": 19, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 19 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_19) as a single string (no quotes).", "gt_ans": "reworked"}
{"idx": 20, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 20 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_20) as a single string (no quotes).", "gt_ans": "reworks"}
{"idx": 21, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 21 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_21) as a single string (no quotes).", "gt_ans": "recooks"}
{"idx": 22, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 22 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_22) as a single string (no quotes).", "gt_ans": "anticooks"}
{"idx": 23, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 23 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_23) as a single string (no quotes).", "gt_ans": "anticooker"}
{"idx": 24, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 24 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_24) as a single string (no quotes).", "gt_ans": "antiwriteer"}
{"idx": 25, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 25 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_25) as a single string (no quotes).", "gt_ans": "prewriteer"}
{"idx": 26, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 26 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_26) as a single string (no quotes).", "gt_ans": "prewriteing"}
{"idx": 27, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 27 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_27) as a single string (no quotes).", "gt_ans": "pretraveling"}
{"idx": 28, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 28 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_28) as a single string (no quotes).", "gt_ans": "untraveling"}
{"idx": 29, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 29 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_29) as a single string (no quotes).", "gt_ans": "untraveled"}
{"idx": 30, "type": "morphology-adhere-drop-cyclic", "task": "You are given a tiny morphology machine that builds words by\ngluing morphemes in a fixed cycle and **always rotating** choices by index tables.\n\n### Inventories\n- Roots (R): ['play', 'work', 'write', 'cook', 'travel']\n- Prefixes (P): ['un', 're', 'pre', 'anti']\n- Suffixes (S): ['s', 'ed', 'ing', 'er']\n\n### Start state\n- Original root: R[0] = \"play\"\n- No prefix and no suffix are attached initially.\n- Surface word at step 0: w0 = \"play\"\n\n### Cycle order\nThe machine visits classes in this exact loop:\nprefix → suffix → root → prefix → suffix → root → …\n\n### Rotation rule when a class is visited\n- You **SET** that class to the **next** item given by its index table (wrapping around).\n  - On the very first visit to a class, this acts like an initial \"attach\".\n  - On later visits, it **rotates** to the next item; nothing is ever removed.\n  - Prefix and suffix therefore remain present once first attached.\n  - The root cycles through the root inventory according to its index table (including the original root).\n\n### Index tables\nThe tables below are lists of integer indices (0-based). Each time you visit a class,\nadvance one position in that class’s table (cycling if necessary) and set the class to\nthe corresponding item from the inventory.\n\n- Prefix index table: [2, 0, 1, 3]\n- Suffix index table: [2, 1, 0, 3]\n- Root index table:   [1, 3, 2, 4, 0]\n\n**Example (prefix):**\nIf the prefix index table is [2,0,1,3], then across successive prefix steps you set:\nP[2] → P[0] → P[1] → P[3] → (wrap) P[2] → …\n\n### Spelling-out\nAfter each update, spell the surface form as: [prefix][root][suffix]\n(plain concatenation; no orthographic tweaks).\n\n### Your task\nStart from w0 and run **exactly N = 30 steps** following the cycle and rotation rule above.\nReturn the final surface form w_N(w_30) as a single string (no quotes).", "gt_ans": "unplayed"}
