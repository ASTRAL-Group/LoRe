{"idx": 1, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=1, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 1}
{"idx": 2, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=2, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 3}
{"idx": 3, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=3, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 4}
{"idx": 4, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=4, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 4}
{"idx": 5, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=5, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 5}
{"idx": 6, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=6, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 5}
{"idx": 7, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=7, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 6}
{"idx": 8, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=8, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 6}
{"idx": 9, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=9, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 7}
{"idx": 10, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=10, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 7}
{"idx": 11, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=11, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 8}
{"idx": 12, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=12, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 8}
{"idx": 13, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=13, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 9}
{"idx": 14, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=14, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 9}
{"idx": 15, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=15, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 10}
{"idx": 16, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=16, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 10}
{"idx": 17, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=17, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 11}
{"idx": 18, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=18, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 11}
{"idx": 19, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=19, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 12}
{"idx": 20, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=20, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 12}
{"idx": 21, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=21, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 13}
{"idx": 22, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=22, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 13}
{"idx": 23, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=23, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 14}
{"idx": 24, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=24, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 14}
{"idx": 25, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=25, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 15}
{"idx": 26, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=26, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 15}
{"idx": 27, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=27, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 16}
{"idx": 28, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=28, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 16}
{"idx": 29, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=29, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 17}
{"idx": 30, "type": "linear-mono-math-boolean-rotflip-3x3", "task": "Given an integer n=30, a 3×3 binary board G_0 (0/1) as three row-strings:\n\n010\n101\n011\n\nApply the following procedure for t = 1..n to obtain G_t and a running score:\n\n1) **Rotate** the whole board 90° clockwise.\n2) **Flip center**: toggle the middle cell (row=1, col=1; 0-indexed) between 0 and 1.\n3) **Synchronous neighborhood XOR update**:\n   Let F be the board after steps (1) and (2). Build G_t from F *synchronously*:\n   - The center cell keeps F[1][1].\n   - For every other cell (r,c), set\n       G_t[r][c] = F[r-1][c] ⊕ F[r+1][c] ⊕ F[r][c-1] ⊕ F[r][c+1],\n     where out-of-bounds neighbors are treated as 0, and ⊕ is XOR over {0,1}.\n   (Synchronous means all reads are from F; the update order does not matter.)\n4) **Score accumulation** (anti-diagonal / secondary diagonal, bottom-left → top-right):\n   After you obtain G_t, add s_t = G_t[2][0] + G_t[1][1] + G_t[0][2] to the running total：\n    score ← score + s_t.\n\nFinally, output the integer x = score mod 1000 as the final answer.\nConventions: indices r,c ∈ {0,1,2}; the clockwise rotation mapping is (r,c) → (c, 2−r).", "gt_ans": 17}
