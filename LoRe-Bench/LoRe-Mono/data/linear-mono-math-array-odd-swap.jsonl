{"idx": 1, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=1, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 2}
{"idx": 2, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=2, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 6}
{"idx": 3, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=3, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 0}
{"idx": 4, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=4, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 2}
{"idx": 5, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=5, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 5}
{"idx": 6, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=6, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 9}
{"idx": 7, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=7, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 10}
{"idx": 8, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=8, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 5}
{"idx": 9, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=9, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 2}
{"idx": 10, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=10, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 4}
{"idx": 11, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=11, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 6}
{"idx": 12, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=12, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 9}
{"idx": 13, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=13, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 0}
{"idx": 14, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=14, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 6}
{"idx": 15, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=15, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 1}
{"idx": 16, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=16, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 9}
{"idx": 17, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=17, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 0}
{"idx": 18, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=18, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 2}
{"idx": 19, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=19, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 5}
{"idx": 20, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=20, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 2}
{"idx": 21, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=21, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 2}
{"idx": 22, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=22, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 8}
{"idx": 23, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=23, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 10}
{"idx": 24, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=24, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 10}
{"idx": 25, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=25, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 1}
{"idx": 26, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=26, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 5}
{"idx": 27, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=27, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 2}
{"idx": 28, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=28, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 2}
{"idx": 29, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=29, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 8}
{"idx": 30, "type": "linear-monotonicity-array-odd-swap", "task": "Given integers K=8, m=10, n=30, and mod_num=11, and the initial 0-indexed array\nA_0 = [1, 2, 3, 5, 9, 3, 1, 1].\n\nBefore the loop, reduce every entry of A_0 modulo m, ensuring all values lie in [0, m-1].\n\nFor t = 1..n, repeat the following on a ring (indices mod K):\n1) Let i = (t-1) mod K, L = (i-1) mod K, R = (i+1) mod K.\n2) Update A[i] ← (A[i] + A[L]) mod m.   (All modulo results are taken as non-negative residues in [0, m-1].)\n3) If A[i] is odd, swap A[i] and A[R].\n4) Accumulate score: score ← score + A[i], where A[i] is the value AFTER the possible swap in step 3.\n\nInitialize score = 0 and A = A_0. After completing all n steps, output:\n    (score mod mod_num)\n\nReturn this single integer as the final answer.\n", "gt_ans": 10}
