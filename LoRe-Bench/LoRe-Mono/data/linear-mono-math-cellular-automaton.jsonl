{"idx": 1, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=1\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=1\\) steps, encode \\(s_1\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_1[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 51}
{"idx": 2, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=2\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=2\\) steps, encode \\(s_2\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_2[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 46}
{"idx": 3, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=3\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=3\\) steps, encode \\(s_3\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_3[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 105}
{"idx": 4, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=4\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=4\\) steps, encode \\(s_4\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_4[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 15}
{"idx": 5, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=5\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=5\\) steps, encode \\(s_5\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_5[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 88}
{"idx": 6, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=6\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=6\\) steps, encode \\(s_6\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_6[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 85}
{"idx": 7, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=7\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=7\\) steps, encode \\(s_7\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_7[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 21}
{"idx": 8, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=8\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=8\\) steps, encode \\(s_8\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_8[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 117}
{"idx": 9, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=9\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=9\\) steps, encode \\(s_9\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_9[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 5}
{"idx": 10, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=10\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=10\\) steps, encode \\(s_10\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_10[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 77}
{"idx": 11, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=11\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=11\\) steps, encode \\(s_11\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_11[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 57}
{"idx": 12, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=12\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=12\\) steps, encode \\(s_12\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_12[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 39}
{"idx": 13, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=13\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=13\\) steps, encode \\(s_13\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_13[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 60}
{"idx": 14, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=14\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=14\\) steps, encode \\(s_14\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_14[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 98}
{"idx": 15, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=15\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=15\\) steps, encode \\(s_15\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_15[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 86}
{"idx": 16, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=16\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=16\\) steps, encode \\(s_16\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_16[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 84}
{"idx": 17, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=17\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=17\\) steps, encode \\(s_17\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_17[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 87}
{"idx": 18, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=18\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=18\\) steps, encode \\(s_18\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_18[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 20}
{"idx": 19, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=19\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=19\\) steps, encode \\(s_19\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_19[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 54}
{"idx": 20, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=20\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=20\\) steps, encode \\(s_20\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_20[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 101}
{"idx": 21, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=21\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=21\\) steps, encode \\(s_21\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_21[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 29}
{"idx": 22, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=22\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=22\\) steps, encode \\(s_22\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_22[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 113}
{"idx": 23, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=23\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=23\\) steps, encode \\(s_23\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_23[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 11}
{"idx": 24, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=24\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=24\\) steps, encode \\(s_24\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_24[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 90}
{"idx": 25, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=25\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=25\\) steps, encode \\(s_25\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_25[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 82}
{"idx": 26, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=26\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=26\\) steps, encode \\(s_26\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_26[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 94}
{"idx": 27, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=27\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=27\\) steps, encode \\(s_27\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_27[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 80}
{"idx": 28, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=28\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=28\\) steps, encode \\(s_28\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_28[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 89}
{"idx": 29, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=29\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=29\\) steps, encode \\(s_29\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_29[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 23}
{"idx": 30, "type": "linear-monotonicity-cellular-automaton", "task": "Given integer \\(n=30\\), start with the binary string \\(s_0 = [0, 1, 0, 0, 0, 0, 1]\\) (length \\(L=7\\)). For each step \\(t=0,1,\\dots,n-1\\), update all bits simultaneously to obtain \\(s_{t+1}\\) using a radius-1 cellular automaton with wrap-around (periodic) boundaries:\n\nFor each index \\(i\\), let \\(\\ell = s_t[(i-1) \\bmod L]\\), \\(c = s_t[i]\\), \\(r = s_t[(i+1) \\bmod L]\\). The next bit is \\(s_{t+1}[i] = f(\\ell,c,r)\\) where \\(f\\) is defined by:\n\\(000 \\to 0,\\; 001 \\to 1,\\; 010 \\to 1,\\; 011 \\to 1,\\; 100 \\to 1,\\; 101 \\to 0,\\; 110 \\to 0,\\; 111 \\to 0\\).\n(This is Wolfram's Rule 30.)\n\nAfter \\(n=30\\) steps, encode \\(s_30\\) as a base-2 integer in big-endian order:\n\\(x = \\sum_{i=0}^{L-1} s_30[i] \\cdot 2^{L-1-i}\\).\nReturn \\(x\\) as the final answer.", "gt_ans": 116}
