{"idx": 1, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 1\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_1 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 33}
{"idx": 2, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 2\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_2 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 10}
{"idx": 3, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 3\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_3 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 13}
{"idx": 4, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 4\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_4 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 6}
{"idx": 5, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 5\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_5 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 8}
{"idx": 6, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 6\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_6 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 4}
{"idx": 7, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 7\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_7 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 7}
{"idx": 8, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 8\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_8 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 6}
{"idx": 9, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 9\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_9 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 9}
{"idx": 10, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 10\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_10 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 6}
{"idx": 11, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 11\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_11 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 9}
{"idx": 12, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 12\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_12 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 6}
{"idx": 13, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 13\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_13 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 10}
{"idx": 14, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 14\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_14 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 8}
{"idx": 15, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 15\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_15 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 12}
{"idx": 16, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 16\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_16 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 8}
{"idx": 17, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 17\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_17 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 12}
{"idx": 18, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 18\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_18 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 8}
{"idx": 19, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 19\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_19 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 13}
{"idx": 20, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 20\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_20 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 10}
{"idx": 21, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 21\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_21 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 15}
{"idx": 22, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 22\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_22 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 10}
{"idx": 23, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 23\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_23 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 15}
{"idx": 24, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 24\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_24 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 10}
{"idx": 25, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 25\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_25 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 16}
{"idx": 26, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 26\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_26 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 12}
{"idx": 27, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 27\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_27 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 18}
{"idx": 28, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 28\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_28 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 12}
{"idx": 29, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 29\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_29 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 18}
{"idx": 30, "type": "rle-alt-odd_len_digit-even_len-sum-mod", "task": "You are given:\n- Initial digit string S0 = \"339993422222\" (characters are '0'..'9' only)\n- Number of iterations n = 30\n- Modulus mod_num = 97\n\nWe define two transforms on any digit string S, both operating on maximal runs of identical digits:\n\n1) Odd-step transform R_odd (Length + Digit):\n   For each run consisting of digit d repeated k times (i.e., d^k),\n   write the base-10 decimal representation of k (no leading zeros),\n   immediately followed by the digit d. Concatenate these pieces from left to right.\n\n2) Even-step transform R_even (Length only):\n   For each run d^k, write only the base-10 decimal representation of k (no leading zeros).\n   Concatenate the lengths from left to right.\n\nIteration:\n- Starting from S0, apply exactly n transforms, alternating by step parity:\n  S1 = R_odd(S0), S2 = R_even(S1), S3 = R_odd(S2), and so on.\n  In general, if t is odd use R_odd; if t is even use R_even, producing S_t.\n\nWorked example (two steps):\n- Let S0 = \"3322251\".\n  · Odd step (R_odd):  S1 = \"23321511\"   (\"33\"→\"23\", \"222\"→\"32\", \"5\"→\"15\", \"1\"→\"11\")\n  · Even step (R_even): S2 = \"121112\"    (run lengths of S1 concatenated)\n\nObjective:\n- Treat every character in S_30 as a decimal digit and sum them; call the result sum.\n- Output a single integer: sum mod 97.\n\nNotes:\n- Run lengths can be multi-digit (e.g., k=10 yields the two characters '1' and '0').\n- No separators are used at any time; all outputs are raw digit strings.\nReturn only the final integer.", "gt_ans": 12}
