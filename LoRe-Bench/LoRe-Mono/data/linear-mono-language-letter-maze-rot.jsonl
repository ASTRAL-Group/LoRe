{"idx": 1, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=1. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=1 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "ab"}
{"idx": 2, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=2. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=2 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "abl"}
{"idx": 3, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=3. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=3 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "ablq"}
{"idx": 4, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=4. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=4 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "blqb"}
{"idx": 5, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=5. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=5 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "lqbg"}
{"idx": 6, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=6. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=6 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "qbgh"}
{"idx": 7, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=7. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=7 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "bghj"}
{"idx": 8, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=8. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=8 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "ghjs"}
{"idx": 9, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=9. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=9 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "hjsk"}
{"idx": 10, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=10. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=10 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "jske"}
{"idx": 11, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=11. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=11 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "skef"}
{"idx": 12, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=12. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=12 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "kefg"}
{"idx": 13, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=13. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=13 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "efgq"}
{"idx": 14, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=14. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=14 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "fgqb"}
{"idx": 15, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=15. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=15 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "gqbg"}
{"idx": 16, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=16. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=16 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "qbgl"}
{"idx": 17, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=17. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=17 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "bglh"}
{"idx": 18, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=18. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=18 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "glhn"}
{"idx": 19, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=19. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=19 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "lhnd"}
{"idx": 20, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=20. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=20 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "hndt"}
{"idx": 21, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=21. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=21 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "ndtb"}
{"idx": 22, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=22. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=22 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "dtba"}
{"idx": 23, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=23. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=23 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "tbaq"}
{"idx": 24, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=24. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=24 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "baqb"}
{"idx": 25, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=25. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=25 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "aqbp"}
{"idx": 26, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=26. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=26 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "qbpg"}
{"idx": 27, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=27. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=27 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "bpgl"}
{"idx": 28, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=28. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=28 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "pglh"}
{"idx": 29, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=29. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=29 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "glhs"}
{"idx": 30, "type": "letter-maze-vowel-right-consonant-down-with-rotations", "task": "You are given a letter maze and a number of moves n=30. The maze is a rectangular grid of letters G with h=4 rows and w=5 columns:\n\na b c d e\nf g h i j\nk l m n o\np q r s t\n\nStart at the cell (r0, c0) = (0, 0). Build a string S as you move:\n1) First, write down the starting letter G[r0][c0] into S. (This is done before any moves.)\n2) Then repeat the following exactly n=30 times (t = 1..n):\n   • Let (r, c) be your current cell BEFORE moving, and let ch = G[r][c].\n   • Move one step based on ch (case-insensitive):\n       – If ch ∈ {a, e, i, o, u} (a vowel): move RIGHT → c ← (c + 1) mod 5\n       – Otherwise (a consonant): move DOWN → r ← (r + 1) mod 4\n   • After moving to the destination cell (r, c), append its letter G[r][c] to S.\n   • Now mutate the grid based on ch (the letter you moved FROM):\n       – If ch is a vowel: cyclically rotate COLUMN c upward by 1.\n         (Formally, for all i: G[i][c] ← old G[(i + 1) mod 4][c].)\n       – Otherwise (ch is a consonant): cyclically rotate ROW r left by 1.\n         (Formally, for all j: G[r][j] ← old G[r][(j + 1) mod 5].)\n\nImportant: The mutation happens AFTER appending G[r][c] to S, and it affects the grid used for the NEXT iteration. Indices are 0-based and the maze wraps around like a torus.\n\nThus, after n moves, S has length n + 1 (because the starting letter was included).\n\nLet k = 4. Your task is to return the word W made by the LAST k letters of S (in order). Output W as a plain string.", "gt_ans": "lhsj"}
