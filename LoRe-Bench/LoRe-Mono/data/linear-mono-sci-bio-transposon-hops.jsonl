{"idx": 1, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=1 steps, split DNA d_1 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 185}
{"idx": 2, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=2 steps, split DNA d_2 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 201}
{"idx": 3, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=3 steps, split DNA d_3 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 201}
{"idx": 4, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=4 steps, split DNA d_4 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 209}
{"idx": 5, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=5 steps, split DNA d_5 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 197}
{"idx": 6, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=6 steps, split DNA d_6 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 201}
{"idx": 7, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=7 steps, split DNA d_7 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 195}
{"idx": 8, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=8 steps, split DNA d_8 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 197}
{"idx": 9, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=9 steps, split DNA d_9 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 194}
{"idx": 10, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=10 steps, split DNA d_10 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 195}
{"idx": 11, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=11 steps, split DNA d_11 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 195}
{"idx": 12, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=12 steps, split DNA d_12 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 68}
{"idx": 13, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=13 steps, split DNA d_13 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 131}
{"idx": 14, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=14 steps, split DNA d_14 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 195}
{"idx": 15, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=15 steps, split DNA d_15 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 195}
{"idx": 16, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=16 steps, split DNA d_16 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 227}
{"idx": 17, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=17 steps, split DNA d_17 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 179}
{"idx": 18, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=18 steps, split DNA d_18 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 195}
{"idx": 19, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=19 steps, split DNA d_19 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 171}
{"idx": 20, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=20 steps, split DNA d_20 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 179}
{"idx": 21, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=21 steps, split DNA d_21 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 167}
{"idx": 22, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=22 steps, split DNA d_22 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 171}
{"idx": 23, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=23 steps, split DNA d_23 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 165}
{"idx": 24, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=24 steps, split DNA d_24 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 167}
{"idx": 25, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=25 steps, split DNA d_25 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 167}
{"idx": 26, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=26 steps, split DNA d_26 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 168}
{"idx": 27, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=27 steps, split DNA d_27 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 294}
{"idx": 28, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=28 steps, split DNA d_28 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 167}
{"idx": 29, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=29 steps, split DNA d_29 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 230}
{"idx": 30, "type": "transposon-hops-binary-halves-sum", "task": "Consider a circular DNA of length L=16 represented by a 0/1 bitstring d[0..L-1], where 1 marks a transposon and 0 marks an empty site. A transposase head (a pointer) sits at index i₀=1. The initial genome is d₀=[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1]. The hop policy depends on step parity: on odd-numbered steps use Δ_odd=2, on even-numbered steps use Δ_even=-1, with Δ drawn from {-2, -1, +1, +2}.\n\nIndex arithmetic for hops uses wrap-around (mod L). Searches to the right do NOT wrap.\n\nAt each step t = 1..N (1-indexed):\n1) If the head is on a transposon (d[i_t] == 1), let Δ = Δ_odd if t is odd else Δ_even.    Compute j = (i_t + Δ) mod L, swap the bits at i_t and j (the transposon at i_t hops to j),    and set the next head position i_(t+1) = j.\n2) Otherwise (d[i_t] == 0), move the head rightward (i_t+1, i_t+2, ...) until the first index r    with d[r] == 1 is found; if such r exists set i_(t+1) = r; if none exists, keep i_(t+1) = i_t    and leave d unchanged for this step.\n\nAfter exactly N=30 steps, split DNA d_30 at mid = floor(L/2) into two contiguous halves:\n  Left  = d_N[0 .. mid-1],  Right = d_N[mid .. L-1].\nInterpret each half DNA sequence as a big-endian binary integer (index increasing from left to right is most-significant to least-significant; e.g., [1,0,1] = 5, where 1 marks a transposon and 0 marks an empty site). Return the base-10 integer\n  y = int(Left) + int(Right).\nIndices are 0-based; step parity uses t starting at 1.", "gt_ans": 294}
